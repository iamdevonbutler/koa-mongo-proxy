// schema.
'account.name': {
  required: true
}
'account.email': {
  type: Types.email
  required: true
}

// payload
{
  $set: {
    'account.name': 'jimbob'
  }
}

///////////////////////////

different kinds of gets...
embedded field get, subdocument get.
how to tell which is which?
inserts are always subdocument gets.
same w/ upserts.
only updates have the potential to perform and embedded field get.
embedded fields must have $set
and have a dot in the key
the value is either a scalar or object.
if scalar that's good.
if it's an object (subdoc), we process the subdoc as an insert.
and since there is a dot in the key, we don't need to bother w/
required siblings and setting defaults in the containing obj (subdoc)
one level up.

* i'm thinking that subdocuments in arrays should be processed in isolation
from their origins. set keys in schema to be relative to the subdocument.

* as an aside, upserts can have both $set and $set on insert, and we
need a way to grab an aggregate payload for processing all fields.

* setoninsert, combine the two payloads for processing - it's an upsert potentially
so we process as an insert.

* addToSet operations and push should do things differently - it;s a single
field update. no need to process it like an entire document.



///////////////////////////



  // setDefaults() {
  //   var value, fieldSchema;
  //   value = this.value;
  //   fieldSchema = this.fieldSchema;
  //   if (value === undefined && fieldSchema.default !== undefined) {
  //     this.value = fieldSchema.default;
  //   }
  // }
  

  // enforceRequiredFields() {
  //   var schema, schemaKeys, payload, errors = [];
  //   schema = this._schema;
  //   payload = this._payload;
  //   schemaKeys = Object.keys(schema);
  //   payload.forEach((payload2, i) => {
  //     schemaKeys.forEach((schemaKey) => {
  //       var field, fieldSchema;
  //       field = payload2[schemaKey];
  //       console.log(schemaKey);
  //       fieldSchema = schema[schemaKey];
  //       if (fieldSchema.required && (!field || field.value === undefined)) {
  //         if (field && field.parentKey && payload2[field.parentKey] && payload2[field.parentKey].value === undefined) {
  //           return;
  //         }
  //         errors.push({
  //           field: schemaKey,
  //           property: 'required',
  //           value: field && field.value,
  //           documentNumber: i,
  //         });
  //       }
  //     });
  //   });
  //   return errors && errors.length ? errors : null;
  // }

  /**
   * Ensure all fields marked required=true in schema are not
   * `undefined` in playload.
   * @param {String} [parentKey] - appends parent key to process subdocuments in arrays.
   * @return {Array of errors | null}
   * @tests unit.
   * @api public.
   */
  // enforceRequiredFields(parentKey = '') {
  //   // @todo remove.
  //   return null;
  //   console.log(2323232);
  //
  //   var schema, schemaKeys, payload, errors = [];
  //   schema = this._schema;
  //   schemaKeys = Object.keys(schema);
  //   payload = this._payload;
  //
  //   payload.forEach((payload2, documentNumber) => {
  //     var schemaHasRequireds = schemaKeys.some(key => schema[key].required);
  //     if (schemaHasRequireds && !isType(payload2, 'object')) {
  //       errors.push({
  //         field: parentKey ? 'Empty subdocument' : 'Empty payload',
  //         property: 'required',
  //         value: payload2,
  //         documentNumber,
  //       });
  //       return;
  //     }
  //     schemaKeys.forEach((key) => {
  //       var fieldSchema = schema[key];
  //       if (fieldSchema.required) {
  //         let payloadKey = parentKey ? key.slice(parentKey.length+1) : key;
  //         if (!payload2[payloadKey] || payload2[payloadKey].value === undefined) {
  //           // Subdocument field can be required, but that's only enforced,
  //           // if the subdocument itself is present or is required.
  //           // let isSubdocumentInArray = fieldSchema._isSubdocumentInArray;
  //           // if (!isSubdocumentInArray) {
  //
  //           // there's gotta be a better way to do this....
  //             console.log(12121212);
  //             errors.push({
  //               field: key,
  //               property: 'required',
  //               value: payload2[payloadKey] ? payload2[payloadKey].value : undefined,
  //               documentNumber,
  //             });
  //           // }
  //         }
  //       }
  //     });
  //   });
  //   return errors && errors.length ? errors : null;
  // }

  /**
   * Set defaults if a field value is `undefined` and the `default` property
   * for the field schema is not `undefined`.
   */
  // setDefaults() {
  //   var schema, schemaKeys, payload, errors = [], containerArrays = [];
  //   schema = this._schema;
  //   schemaKeys = Object.keys(schema);
  //   payload = this._payload;
  //   schemaKeys.forEach((key) => {
  //     var fieldSchema = schema[key];
  //     if (fieldSchema.default !== undefined && payload[key] === undefined) {
  //       // Subdocument field can be required, but that's only enforced,
  //       // if the subdocument itself is present or is required.
  //       let isSubdocumentInArray = fieldSchema._isSubdocumentInArray;
  //       if (!isSubdocumentInArray) {
  //         payload[key] = {
  //           payloadPath: key,
  //           value: fieldSchema.default,
  //         };
  //       }
  //     }
  //   });
  // }

  /**
   * Validate and transform a payload(s).
   * @param {String} [parentKey] - appends parent key to process subdocuments in arrays.
   * @param {String} cacheKey - prefix to SubdocumentPreprocessor obj caching.
   * @return {Array of errors|null}
   */
  // preprocess(parentKey = '', cacheKey) {
  //   var payload, schema, errors = [];
  //   payload = this._payload;
  //   schema = this._schema;
  //   payload.forEach((payload2, i) => {
  //     var payload2Keys;
  //     payload2Keys = Object.keys(payload2);
  //     payload2Keys.forEach((key) => {
  //       var fullKey, fieldValue, fieldSchema, error;
  //       fullKey = parentKey ? parentKey+'.'+key : key;
  //       fieldValue = payload2[key] ? payload2[key].value : undefined;
  //       fieldSchema = schema[fullKey];
  //       ({errors: error, fieldValue} = this.preprocessField(fieldValue, fullKey, fieldSchema, cacheKey));
  //       if (error) {
  //         errors = errors.concat(error);
  //       }
  //       this._payload[i][key].value = fieldValue;
  //     });
  //   });
  //   return errors && errors.length ? errors : null;
  // }

  // preprocessField(fieldValue, fieldKey, fieldSchema, cacheKey) {
  //   var type, errors = [];
  //   type = fieldSchema._type;
  //   switch (type) {
  //     case 'value':
  //       ({errors, fieldValue} = this.preprocessFieldValue(fieldValue, fieldKey, fieldSchema));
  //       break;
  //     case 'arrayofvalues':
  //       ({errors, fieldValue} = this.preprocessArrayOfValues(fieldValue, fieldKey, fieldSchema));
  //       break;
  //     case 'arrayofobjects':
  //       ({errors, fieldValue} = this.preprocessArrayOfObjects(fieldValue, fieldKey, fieldSchema, cacheKey));
  //       break;
  //   }
  //   if (fieldValue !== undefined) {
  //     fieldValue = this.transform(fieldValue, fieldSchema);
  //   }
  //   return {
  //     errors: errors && errors.length ? errors : null,
  //     fieldValue,
  //   };
  // }
  //
  // preprocessFieldValue(fieldValue, fieldKey, fieldSchema) {
  //   var errors;
  //   errors = validatorValues.call(null, fieldValue, fieldKey, fieldSchema);
  //   return {
  //     errors: errors && errors.length ? errors : null,
  //     fieldValue,
  //   };
  // }
  //
  // preprocessArrayOfObjects(fieldValue, fieldKey, fieldSchema, cacheKey) {
  //   var payload, cacheKey, cached, errors = [];
  //
  //   // Validate the array field (not the subdocuments contained w/i).
  //   errors = validatorArrayOfObjects1.call(null, fieldValue, fieldKey, fieldSchema);
  //   if (errors && errors.length) {
  //     return errors;
  //   }
  //
  //   cacheKey = cacheKey + '.' + fieldKey;
  //   cached = cache.get(cacheKey);
  //   if (cached) {
  //     ({errors, payload} = cached.preprocessFromCache(fieldValue, fieldKey, cacheKey));
  //     if (errors && errors.length) return errors;
  //   }
  //   else {
  //     let obj, schema = {};
  //     schema = getSubdocumentSchema(fieldKey, this._schema);
  //     obj = new this.SubdocumentPreprocessor(schema);
  //     obj.addPayload(fieldValue, fieldKey);
  //     errors = obj.preprocess(fieldKey, cacheKey);
  //     if (errors) return errors;
  //     payload = obj.getPayload();
  //     obj.resetPayload();
  //     cache.set(cacheKey, obj);
  //   }
  //
  //   // Update fieldValue array w/ our newly preprocessed subdocument.
  //   fieldValue = fieldValue.map((value, i) => payload[i]);
  //
  //   return {
  //     errors: errors && errors.length ? errors : null,
  //     fieldValue,
  //   }
  // }
  //
  // preprocessArrayOfValues(fieldValue, fieldKey, fieldSchema) {
  //   var parents, errors = [];
  //   errors = validatorArrayOfValues1.call(null, fieldValue, fieldKey, fieldSchema);
  //   if (!errors) {
  //     let isArray = isType(fieldValue, 'array');
  //     if (isArray) {
  //       fieldValue.forEach((value) => {
  //         let error;
  //         error = validatorArrayOfValues2.call(null, value, fieldKey, fieldSchema);
  //         if (error) {
  //           errors = errors.concat(error);
  //         }
  //       });
  //     }
  //   }
  //   return {
  //     errors: errors && errors.length ? errors : null,
  //     fieldValue,
  //   }
  // }
  //
  // transform(value, fieldSchema) {
  //   var type;
  //   type = fieldSchema._type;
  //   switch (type) {
  //     case 'value':
  //       return transformValue(value, fieldSchema, 0);
  //     case 'arrayofvalues':
  //       return this.transformArrayOfValues(value, fieldSchema);
  //     case 'arrayofobjects':
  //       return this.transformArrayOfObjects(value, fieldSchema);
  //   }
  //       return x;
  // }
  //
  // transformArrayOfObjects(value, fieldSchema) {
  //   return transformFunction(value, fieldSchema, 0);
  // }
  //
  // transformArrayOfValues(value, fieldSchema) {
  //   var value2, isArray;
  //   value2 = transformFunction(value, fieldSchema, 0);
  //   isArray = isType(value2, 'array');
  //   if (isArray) {
  //     value2 = value2.map((value3) => {
  //       return transformValue(value3, fieldSchema, 1);
  //     });
  //   }
  //   return value2;
  // }

  /**
   * @todo - intented as a means to skip validating children in
   * schema when the parent container dne.
   */
  // _parentIsEmpty(childKey) {
  //   var keys, parents;
  //   parents = this._arrayContainers;
  //   keys = Object.keys(parents).reverse();
  //   for (let key of keys) {
  //     let startsWith = childKey.startsWith(key);
  //     if (startsWith) {
  //       return parents[key].isEmpty;
  //     }
  //   }
  //   return false;
  // }


  // From insert.preprocess
  /**
   * Ensure all fields in payload are present in schema.
   * Prevents the insertion of fields not found in schema.
   * @param {Array} payload
   * @param {Array} args
   * @return {Error|null}
   */
  ensureFieldsExistInSchema(payload, args) {
    var schema, payload, errors = [];
    schema = this._schema;
    payload.forEach((payload2, documentNumber) => {
      var payloadKeys = getPayloadKeys(payload2);
      payloadKeys.forEach((payloadKey) => {
        var fieldExistsInSchema;
        fieldExistsInSchema = !!schema[payloadKey];
        if (!fieldExistsInSchema) {
          errors.push(`Field "${payloadKey}" does not exist in schema (document #${documentNumber}).`);
        }
      });
    });
    return errors && errors.length ? errors : null;
  }


//udpate.preprocess
  /**
   * Ensure all fields in payload, and in query, are present in schema.
   * Some update operations insert data from the query.
   * Prevents the insertion of fields not found in schema.
   * @param {Array} payload
   * @param {Array} args
   * @return {Error|null}
   */
  ensureFieldsExistInSchema(payload, args) {
    var validQuery, schema, errors = [];
    schema = this._schema;
    // Validate query.
    validQuery = this._queryFieldsExistInSchema(args[0]);
    if (!validQuery) {
      errors.push(`Query fields do not exist in schema.`);
    }
    // Validate payload.
    payload.forEach((payload2, documentNumber) => {
      var payloadKeys = getPayloadKeys(payload2);
      payloadKeys.forEach((payloadKey) => {
        var fieldExistsInSchema;
        payloadKey = cleanUpdateKey(payloadKey);
        fieldExistsInSchema = !!schema[payloadKey];
        if (!fieldExistsInSchema) {
          errors.push(`Field "${payloadKey}" does not exist in schema (document #${documentNumber}).`);
        }
      });
    });
    return errors && errors.length ? errors : null;
  }

  /**
   * Ensures that a update operation, with upsert = true,
   * has a query that only contains fields that exist in schema.
   * @param {Object} query
   * @param {Object} schema
   * @return {Boolean}
   * @api private.
   * @tests unit. @todo migrate tests.
   */
  _queryFieldsExistInSchema(query) {
    var queryFields, schemaFields, schema;
    schema = this._schema;
    queryFields = getQueryFields(query);
    schemaFields = Object.keys(schema);
    return !queryFields.some((queryField) => {
      return schemaFields.indexOf(queryField) === -1;
    });
  }
